<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoMarket: El Journey hacia Colas de Mensajes</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .phase {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .phase h2 {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .phase h2::before {
            content: attr(data-icon);
            font-size: 1.5em;
            margin-right: 10px;
        }
        .activity {
            background: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .checkpoint {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .reflection {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .evolution-step {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
        }
        .evolution-step::after {
            content: "↓";
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #3498db;
        }
        .evolution-step:last-child::after {
            display: none;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            background: white;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .decision-matrix {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .ai-prompt {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }
        .progress-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            margin: 0 5px;
            border-radius: 5px;
        }
        .progress-item.active {
            background: #3498db;
            color: white;
        }
        .scenario-box {
            background: #f0f8ff;
            border: 1px solid #3498db;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .diagram {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>EcoMarket: El Journey hacia Colas de Mensajes</h1>
    <p>De problemas simples a soluciones evolutivas: Por qué y cuándo necesitas RabbitMQ</p>

    <div class="progress-bar">
        <div class="progress-item active">🎯 Fase 0: El Problema Real</div>
        <div class="progress-item">🔄 Fase 1: Evolución de Soluciones</div>
        <div class="progress-item">💻 Fase 2: Implementando RabbitMQ</div>
        <div class="progress-item">🧪 Fase 3: Validación</div>
    </div>

    <div class="phase">
        <h2 data-icon="🎯">Fase 0: El Problema Real que Justifica la Complejidad (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Entender EXACTAMENTE por qué las soluciones simples fallan antes de saltar a RabbitMQ. Al final, podrás justificar cada gramo de complejidad adicional que introduces.</p>

        <h3>🏪 Escenario: EcoMarket en Crisis</h3>
        <p>Tu implementación HTTP directa funciona bien... hasta que no. Han llegado reportes preocupantes:</p>

        <div class="scenario-box">
            <h4>📊 Datos Reales del Sistema Actual:</h4>
            <ul>
                <li><strong>Volumen:</strong> 50 ventas por hora en horarios pico</li>
                <li><strong>Latencia de red:</strong> 200ms promedio entre sucursal y central</li>
                <li><strong>Fallos de red:</strong> 2-3% de las notificaciones HTTP fallan</li>
                <li><strong>Tiempo de recuperación:</strong> Cuando central se cae, tarda 5-10 minutos en volver</li>
                <li><strong>Costo de venta perdida:</strong> $180 promedio por venta</li>
            </ul>
        </div>

        <div class="scenario-box">
            <h4>📈 Diagrama: El Problema Actual que Justifica la Inversión</h4>
            <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
SITUACIÓN ACTUAL: HTTP Directo
┌─────────────┐    HTTP POST     ┌─────────────┐
│ Sucursal    │ ──────────────── │ Central     │
│ (vende)     │ ← 3-5 segundos → │ (actualiza) │
└─────────────┘                  └─────────────┘
      │                                   ❌
      │ Si Central está caído:           │
      ├──X── Request timeout            │
      ├──X── Cliente se va frustrado    │
      └──X── Venta perdida: $180        │

COSTO REAL: 2% fallos × 400 ventas/día × $180 = $1,440 perdidos/día
ESCALAMIENTO: 10 sucursales = $14,400 perdidos/día en fallos
            </pre>
        </div>

        <div class="warning">
            <h3>⚠️ Los Síntomas del Dolor</h3>
            <p><strong>Reporte del Gerente:</strong> "Ayer perdimos 8 ventas porque el sistema se quedó 'pensando' y los clientes se fueron frustrados."</p>
            <p><strong>Reporte Técnico:</strong> Durante la caída de 8 minutos del servidor central, las sucursales no pudieron procesar ventas porque esperaban confirmación del inventario.</p>
            <p><strong>Impacto:</strong> 8 ventas × $180 = $1,440 perdidos en una sola hora.</p>
        </div>

        <div class="activity">
            <h3>🧮 Actividad: Calculando el Costo de No Actuar</h3>
            <p>Antes de buscar soluciones, cuantifica el problema:</p>
            <ol>
                <li><strong>Con tu equipo, calculen:</strong> Si el sistema actual falla 2% de las veces y procesan 400 ventas/día, ¿cuánto dinero pierden al mes?</li>
                <li><strong>Proyecten crecimiento:</strong> Si EcoMarket crece a 10 sucursales, ¿cómo escala el problema?</li>
                <li><strong>Definan umbral de dolor:</strong> ¿A partir de qué pérdida mensual vale la pena invertir tiempo en una solución más compleja?</li>
            </ol>
            <p><strong>Meta:</strong> Tener un número concreto que justifique la inversión en mejoras.</p>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt para IA: Análisis de Impacto</h4>
            <pre>Ayúdame a analizar el impacto de fallos en mi sistema de ventas:

Contexto:
- Ventas por día: 400
- Valor promedio por venta: $180
- Tasa de fallos actual: 2%
- Tiempo promedio de caída: 8 minutos
- Frecuencia de caídas: 2 veces por semana

Preguntas:
1. ¿Cuál es el costo mensual de los fallos actuales?
2. Si crecemos 5x en volumen, ¿cómo escala el problema?
3. ¿A partir de qué punto un fallo de sistema se vuelve crítico para el negocio?
4. ¿Qué otros costos ocultos podría estar pasando por alto?

Dame números específicos y escenarios concretos.</pre>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint de Fase 0 - Rúbrica de Evaluación</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Criterio</th>
                        <th>¿Cumple?</th>
                        <th>Evidencia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Calculé el costo real mensual de los fallos actuales</td>
                        <td>□ Sí / □ No</td>
                        <td>Tengo el número: $______ /mes</td>
                    </tr>
                    <tr>
                        <td>Identifiqué el umbral donde justifica invertir en mejoras</td>
                        <td>□ Sí / □ No</td>
                        <td>Si pérdidas > $______, invierto en RabbitMQ</td>
                    </tr>
                    <tr>
                        <td>Entiendo por qué "funciona en mi máquina" no es suficiente</td>
                        <td>□ Sí / □ No</td>
                        <td>Puedo explicar 2 diferencias prod vs dev</td>
                    </tr>
                    <tr>
                        <td>Comparé mi caso con experiencia laboral previa</td>
                        <td>□ Sí / □ No</td>
                        <td>Identifiqué problema similar en mi trabajo</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="🔄">Fase 1: La Evolución Natural de Soluciones (45 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Explorar cada solución incremental y entender EXACTAMENTE dónde falla antes de pasar a la siguiente. Este es el journey que siguen todos los sistemas reales.</p>

        <h3>🚀 El Evolution Journey</h3>
        <p>No saltas directo a RabbitMQ. Evolucionas paso a paso cuando cada solución muestra sus límites:</p>

        <div class="scenario-box">
            <h4>🔄 Diagrama: Evolution Journey - Cada Paso y Dónde Falla</h4>
            <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
PASO 1: HTTP DIRECTO
┌─────────┐ ──HTTP POST─→ ┌─────────┐
│Sucursal │               │Central  │ ✅ Funciona: Todo perfecto
└─────────┘               └─────────┘ ❌ Falla: Red lenta/central caído
    ↓ Problema: 2% fallos = $1,440/día perdidos

PASO 2: HTTP + RETRY SIMPLE  
┌─────────┐ ──┬─retry 1─→ ┌─────────┐
│Sucursal │   ├─retry 2─→ │Central  │ ✅ Funciona: Fallos &lt;30s
└─────────┘   └─retry 3─→ └─────────┘ ❌ Falla: Central caído &gt;1min
    ↓ Problema: Cliente espera 9+ segundos

PASO 3: HTTP + BACKOFF EXPONENCIAL
┌─────────┐ ──┬─1s─→ ┌─────────┐
│Sucursal │   ├─2s─→ │Central  │ ✅ Funciona: Fallos &lt;5min
└─────────┘   ├─4s─→ └─────────┘ ❌ Falla: 10 sucursales simultáneas
              └─8s─→              sobrecargan al central recuperándose
    ↓ Problema: Thundering herd + cliente espera 15+ segundos

PASO 4: COLA EN MEMORIA (Redis)
┌─────────┐ ──push─→ [Redis] ──pop─→ ┌─────────┐
│Sucursal │          Queue          │Central  │ ✅ Funciona: Fallos de horas
└─────────┘                         └─────────┘ ❌ Falla: Redis restart = pérdida
    ↓ Problema: 100ms venta + riesgo pérdida en restart

PASO 5: MESSAGE BROKER (RabbitMQ)
┌─────────┐ ──publish─→ [🐰 Durable] ──consume─→ ┌─────────┐
│Sucursal │             Queue + ACK              │Central  │ ✅ Funciona: Garantías totales
└─────────┘                                     └─────────┘ ❌ Nuevo costo: Infraestructura
    ↓ Solución: 50ms venta + 0% pérdida + escalabilidad

DECISIÓN: ¿Vale la pena la complejidad por las garantías?
          Si pérdidas &gt; costo operacional → SÍ
            </pre>
        </div>

        <div class="evolution-step">
            <h4>Paso 1: HTTP Directo (Tu implementación actual)</h4>
            <p><strong>Código:</strong> `await httpx.post(central_url, json=data)`</p>
            <p><strong>Funciona cuando:</strong> Todo está perfecto</p>
            <p><strong>Falla cuando:</strong> Red lenta, central caído, timeout</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 2: HTTP con Reintentos Simples</h4>
            <p><strong>Código:</strong> Loop de 3 intentos con sleep(1)</p>
            <p><strong>Funciona cuando:</strong> Fallos transitorios</p>
            <p><strong>Falla cuando:</strong> Central caído por más tiempo que tus reintentos</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 3: HTTP con Backoff Exponencial</h4>
            <p><strong>Código:</strong> sleep(2^attempt) entre reintentos</p>
            <p><strong>Funciona cuando:</strong> Fallos de algunos minutos</p>
            <p><strong>Falla cuando:</strong> Central caído por horas, muchas sucursales reintentando</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 4: Cola en Memoria (Redis/Lista)</h4>
            <p><strong>Código:</strong> Push a Redis list, worker que procesa</p>
            <p><strong>Funciona cuando:</strong> Fallos de hasta varias horas</p>
            <p><strong>Falla cuando:</strong> El servidor Redis se reinicia, complejidad de múltiples consumers</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 5: Message Broker (RabbitMQ)</h4>
            <p><strong>Código:</strong> Publish a queue durable, consumer con ACK</p>
            <p><strong>Funciona cuando:</strong> Necesitas garantías de entrega y escalabilidad</p>
            <p><strong>Nuevo costo:</strong> Infraestructura adicional, complejidad operacional</p>
        </div>

        <div class="activity">
            <h3>🧪 Actividad: Implementando y Rompiendo Cada Paso</h3>
            <p>Vamos a implementar y "romper" cada solución para entender dónde falla:</p>

            <h4>Paso 2A: Implementa Reintentos Simples (15 min)</h4>
            <div class="code-block">
                <pre>async def notify_with_simple_retry(data: dict, max_attempts: int = 3):
    for attempt in range(max_attempts):
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.post(CENTRAL_URL, json=data)
                if response.status_code == 200:
                    logger.info(f"✅ Éxito en intento {attempt + 1}")
                    return True
                else:
                    logger.warning(f"⚠️ HTTP {response.status_code} en intento {attempt + 1}")
        except Exception as e:
            logger.error(f"❌ Intento {attempt + 1} falló: {e}")
            if attempt < max_attempts - 1:
                await asyncio.sleep(1)  # Espera fija
    
    logger.error("❌ Falló después de todos los intentos simples")
    return False</pre>
            </div>

            <p><strong>Prueba de ruptura:</strong> Apaga el servidor central por 5 minutos. ¿Qué pasa?</p>
            
            <div class="tip">
                <h4>🤔 ¿Qué pasaría si...?</h4>
                <p><strong>Escenario:</strong> Si tu aplicación se ejecuta en un centro comercial con WiFi intermitente que se corta cada 30 segundos por 10 segundos:</p>
                <ul>
                    <li>Retry simple: 3 intentos × 1s = 3s total → ❌ Falla porque corte dura 10s</li>
                    <li>Cliente espera 3s y ve error → Experiencia frustrante</li>
                    <li>Ventas perdidas en horas pico del centro comercial</li>
                </ul>
            </div>

            <h4>Paso 2B: Mejora con Backoff Exponencial (10 min)</h4>
            <div class="code-block">
                <pre>async def notify_with_backoff(data: dict, max_attempts: int = 5):
    for attempt in range(max_attempts):
        try:
            # ... mismo código de httpx ...
            return True
        except Exception as e:
            logger.error(f"❌ Intento {attempt + 1} falló: {e}")
            if attempt < max_attempts - 1:
                wait_time = 2 ** attempt  # 1, 2, 4, 8, 16 segundos
                logger.info(f"⏰ Esperando {wait_time}s antes del siguiente intento")
                await asyncio.sleep(wait_time)
    
    return False</pre>
            </div>

            <p><strong>Prueba de ruptura:</strong> ¿Qué pasa si 10 sucursales reintentan simultáneamente cuando el central vuelve?</p>
            
            <div class="tip">
                <h4>🤔 ¿Qué pasaría si...?</h4>
                <p><strong>Escenario "Thundering Herd":</strong> Central se cae 5 minutos, 10 sucursales esperando:</p>
                <ul>
                    <li>Todas han acumulado reintentos y esperan 16-32 segundos</li>
                    <li>Central vuelve → las 10 sucursales atacan simultáneamente</li>
                    <li>Central se sobrecarga → vuelve a caerse</li>
                    <li>Ciclo infinito de caída-recovery-sobrecarga</li>
                </ul>
            </div>
        </div>

        <div class="decision-matrix">
            <h3>📊 Matriz de Decisión: ¿Cuándo usar qué?</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Solución</th>
                        <th>Complejidad</th>
                        <th>Funciona hasta</th>
                        <th>Falla cuando</th>
                        <th>Costo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>HTTP Directo</strong></td>
                        <td>Muy Baja</td>
                        <td>10 ventas/hora, red perfecta</td>
                        <td>Cualquier fallo de red</td>
                        <td>Muy Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Retry Simple</strong></td>
                        <td>Baja</td>
                        <td>50 ventas/hora, fallos &lt;30s</td>
                        <td>Central caído &gt;1 min</td>
                        <td>Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Backoff Exponencial</strong></td>
                        <td>Baja-Media</td>
                        <td>100 ventas/hora, fallos &lt;5 min</td>
                        <td>Central caído &gt;15 min, múltiples sucursales</td>
                        <td>Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Cola en Memoria</strong></td>
                        <td>Media</td>
                        <td>500 ventas/hora, fallos &lt;2 horas</td>
                        <td>Servidor de cola se reinicia</td>
                        <td>Medio</td>
                    </tr>
                    <tr>
                        <td><strong>Message Broker</strong></td>
                        <td>Alta</td>
                        <td>Miles/hora, fallos de horas/días</td>
                        <td>Configuración incorrecta</td>
                        <td>Alto</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt para IA: Análisis de Alternativas</h4>
            <pre>Analiza estas alternativas para mi sistema de notificaciones:

Mi contexto específico:
- Volumen actual: 400 ventas/día (50 en hora pico)
- Crecimiento esperado: 5x en próximos 6 meses
- Tolerancia a fallos: máximo 1% de notificaciones perdidas
- Equipo técnico: 2 desarrolladores, sin DevOps dedicado
- Presupuesto: preferencia por soluciones simples

Alternativas evaluando:
1. HTTP con retry + backoff exponencial
2. Redis como cola + worker Python
3. RabbitMQ con durable queues
4. Azure Service Bus (cloud)

Para cada alternativa, evalúa:
- ¿Cumple mis requerimientos actuales?
- ¿Escala para mi crecimiento proyectado?
- ¿Qué esfuerzo de implementación requiere?
- ¿Qué nuevos problemas operacionales introduce?
- ¿En qué punto me forzaría a migrar a algo más complejo?

Recomienda cuál implementar AHORA y cuál sería mi upgrade path.</pre>
        </div>

        <div class="reflection">
            <h3>🤔 Momento de Decisión Crítica</h3>
            <p><strong>Pregunta para tu equipo:</strong> "Basándose en nuestros números reales, ¿en qué punto del journey estamos FORZADOS a dar el siguiente paso?"</p>
            <p><strong>Datos para considerar:</strong></p>
            <ul>
                <li>Costo actual de fallos: $X/mes</li>
                <li>Tiempo de implementación de cada solución</li>
                <li>Complejidad operacional que podemos manejar</li>
                <li>Horizonte de crecimiento realista</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint de Fase 1</h3>
            <ul>
                <li>Implementé y probé al menos 2 alternativas simples</li>
                <li>Entiendo exactamente dónde falla cada solución</li>
                <li>Tengo una justificación cuantitativa para el siguiente paso</li>
                <li>Puedo explicar por qué RabbitMQ no es overkill para mi caso</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="💻">Fase 2: Implementando RabbitMQ con Propósito (60 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Ahora que entiendes POR QUÉ necesitas un message broker, implementa RabbitMQ sabiendo exactamente qué problema específico estás resolviendo.</p>

        <div class="tip">
            <h3>💡 Contexto de la Implementación</h3>
            <p>No estás implementando RabbitMQ porque "es cool" o "es enterprise". Lo implementas porque:</p>
            <ul>
                <li>Necesitas garantías de entrega que HTTP no puede ofrecer</li>
                <li>Tu sistema debe ser resiliente a caídas de horas, no minutos</li>
                <li>Vas a escalar a múltiples sucursales que necesitan procesamiento desacoplado</li>
                <li>El costo de perder notificaciones supera el costo de la complejidad adicional</li>
            </ul>
        </div>

        <h3>🏗️ Arquitectura con Propósito</h3>

        <div class="scenario-box">
            <h4>🎯 Diagrama: Arquitectura Final - Cada Componente Justificado</h4>
            <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
ARQUITECTURA COMPLETA CON GARANTÍAS DE PRODUCCIÓN

┌─────────────────┐                 ┌─────────────────────────────┐
│   SUCURSAL API  │                 │        RABBITMQ BROKER      │
│                 │                 │                             │
│ 1. Venta local  │ ──publish────→  │  ┌─────────────────────┐    │
│    (50ms)       │   (durable +    │  │  sale_notifications │    │
│                 │    confirms)    │  │                     │    │
│ 2. Respuesta    │                 │  │ • Queue durable     │    │
│    inmediata    │                 │  │ • Messages persist  │    │ ──consume──→
│                 │                 │  │ • ACK requerido     │    │   (prefetch=1)
│ 3. Background   │                 │  │ • TTL 24h          │    │
│    task notifica│                 │  │ • Dead letter queue │    │
│                 │                 │  └─────────────────────┘    │
└─────────────────┘                 └─────────────────────────────┘
         │                                                              │
         │ Garantía: Venta NUNCA falla                                  │
         │ por problemas de red                                         │
         │                                          ┌─────────────────────────┐
         │                                          │    CENTRAL API          │
         └──────────── DESACOPLAMIENTO ─────────────│                         │
                                                    │ 1. Consumer robusto     │
                                                    │    • Idempotencia       │
                                                    │    • Error handling     │
                                                    │    • ACK explícito      │
                                                    │                         │
                                                    │ 2. Actualiza inventario │
                                                    │    • Solo tras ACK      │
                                                    │    • Log de auditoría   │
                                                    │                         │
                                                    │ 3. Escalable           │
                                                    │    • Múltiples workers  │
                                                    │    • Load balancing     │
                                                    └─────────────────────────┘

BENEFICIOS ESPECÍFICOS OBTENIDOS:
✅ Tiempo venta: 3-5s → 50ms (95% mejora)
✅ Disponibilidad: 98% → 99.9% (10x mejora)  
✅ Pérdida mensajes: 2% → 0.01% (200x mejora)
✅ Escalabilidad: 1 sucursal → N sucursales
❗ Costo nuevo: Infraestructura + operación RabbitMQ
            </pre>
        </div>

        <div class="scenario-box">
            <h4>📋 Requerimientos Específicos que Cubre RabbitMQ:</h4>
            <ul>
                <li><strong>Durabilidad:</strong> Si el sistema se cae, los mensajes no se pierden</li>
                <li><strong>Acknowledgments:</strong> Solo procesa el mensaje si el consumer confirma éxito</li>
                <li><strong>Prefetch Control:</strong> Evita sobrecargar consumers lentos</li>
                <li><strong>Dead Letter Queues:</strong> Maneja mensajes que fallan repetidamente</li>
                <li><strong>Múltiples Consumers:</strong> Escala horizontalmente cuando creces</li>
            </ul>
        </div>

        <div class="activity">
            <h3>🚀 Actividad: Setup con Conciencia de Producción</h3>
            
            <h4>Setup Docker (10 min)</h4>
            <div class="code-block">
                <pre># docker-compose.yml - CON configuración de producción
version: "3.9"
services:
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"     # AMQP
      - "15672:15672"   # Management UI
    environment:
      RABBITMQ_DEFAULT_USER: ecomarket_user      # NO uses guest en prod
      RABBITMQ_DEFAULT_PASS: ecomarket_password  # Cambiar en prod
      RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS: "-rabbit disk_free_limit 2GB"
    volumes:
      - ./rabbitmq_data:/var/lib/rabbitmq  # Persistencia
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 5</pre>
            </div>

            <div class="tip">
                <h4>💻 Alternativa sin Docker</h4>
                <p>Si no tienes Docker disponible:</p>
                <ul>
                    <li><strong>Mac:</strong> <code>brew install rabbitmq</code> → <code>brew services start rabbitmq</code></li>
                    <li><strong>Windows:</strong> <code>choco install rabbitmq</code> o descarga desde rabbitmq.com</li>
                    <li><strong>Linux:</strong> <code>sudo apt install rabbitmq-server</code> → <code>sudo systemctl start rabbitmq-server</code></li>
                </ul>
                <p>Management UI: <code>sudo rabbitmq-plugins enable rabbitmq_management</code></p>
            </div>

            <p><strong>¿Por qué esta configuración?</strong> Cada línea resuelve un problema específico de producción.</p>
        </div>

        <div class="activity">
            <h3>🔧 Producer: Sucursal con Garantías</h3>
            <p>Tu publisher ahora tiene características de producción:</p>

            <div class="code-block">
                <pre>"""
Sucursal Publisher - CON garantías de entrega
"""
import pika
import json
import logging
from datetime import datetime
import uuid

def publish_sale_with_guarantees(sale_data: dict, max_retries: int = 3):
    """
    Publisher con TODAS las garantías que necesitamos:
    - Publisher confirms (RabbitMQ confirma que recibió)
    - Durable queue (sobrevive restart de RabbitMQ)  
    - Persistent messages (se guardan en disco)
    - Connection handling (reconexión automática)
    """
    
    # Agregar metadata para tracking
    message = {
        **sale_data,
        "message_id": str(uuid.uuid4()),
        "timestamp": datetime.now().isoformat(),
        "source": "sucursal-001",
        "retry_count": 0
    }
    
    for attempt in range(max_retries):
        try:
            # Conexión con parámetros de producción
            params = pika.ConnectionParameters(
                host='localhost',
                port=5672,
                credentials=pika.PlainCredentials('ecomarket_user', 'ecomarket_password'),
                heartbeat=600,  # 10 min heartbeat
                blocked_connection_timeout=300,  # 5 min timeout
            )
            
            with pika.BlockingConnection(params) as connection:
                channel = connection.channel()
                
                # Declarar queue con durabilidad
                channel.queue_declare(
                    queue='sale_notifications',
                    durable=True,  # Sobrevive restart de RabbitMQ
                    arguments={
                        'x-max-retries': 3,
                        'x-message-ttl': 86400000,  # 24 horas TTL
                    }
                )
                
                # Habilitar publisher confirms
                channel.confirm_delivery()
                
                # Publicar con persistencia
                published = channel.basic_publish(
                    exchange='',
                    routing_key='sale_notifications',
                    body=json.dumps(message),
                    properties=pika.BasicProperties(
                        delivery_mode=2,  # Persistent
                        message_id=message["message_id"],
                        correlation_id=sale_data.get("sale_id"),
                        headers={'source': 'sucursal-001'}
                    ),
                    mandatory=True  # Falla si queue no existe
                )
                
                if published:
                    logger.info(f"✅ Mensaje publicado exitosamente: {message['message_id']}")
                    return True
                else:
                    logger.warning(f"⚠️ RabbitMQ no confirmó el mensaje")
                    
        except Exception as e:
            logger.error(f"❌ Intento {attempt + 1} falló: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Backoff exponencial
    
    logger.error(f"❌ Falló publicar después de {max_retries} intentos")
    # En producción: guardar en local DB para retry posterior
    return False</pre>
            </div>
            
            <div class="tip">
                <h4>🚀 Teaser: Escalando para el Futuro</h4>
                <p><strong>Para 2000+ ventas/día:</strong> Tu implementación actual es la base sólida. Próximos pasos naturales:</p>
                <ul>
                    <li><strong>Cluster RabbitMQ:</strong> 3 nodos para alta disponibilidad</li>
                    <li><strong>HAProxy/Load Balancer:</strong> Distribuir carga entre consumers</li>
                    <li><strong>Múltiples workers:</strong> Horizontal scaling del processing</li>
                    <li><strong>Monitoreo:</strong> Prometheus + Grafana para métricas</li>
                </ul>
                <p>Pero por ahora, enfócate en dominar los fundamentals 🎯</p>
            </div>
        </div>

        <div class="activity">
            <h3>📥 Consumer: Central con Procesamiento Robusto</h3>

            <div class="code-block">
                <pre>"""
Central Consumer - CON procesamiento robusto
"""
import pika
import json
import logging
from typing import Set

# Para idempotencia (en prod: usar Redis o DB)
processed_messages: Set[str] = set()

def process_sale_message(ch, method, properties, body):
    """
    Consumer que maneja TODOS los edge cases:
    - Idempotencia (no procesar duplicados)
    - Error handling (ACK/NACK apropiado)
    - Logging para debugging
    - Validación de datos
    """
    
    try:
        # Parsear mensaje
        message = json.loads(body)
        message_id = message.get('message_id')
        sale_id = message.get('sale_id')
        
        logger.info(f"📨 Recibido mensaje: {message_id} para venta {sale_id}")
        
        # Idempotencia: ¿Ya procesamos este mensaje?
        if message_id in processed_messages:
            logger.info(f"⏭️ Mensaje duplicado ignorado: {message_id}")
            ch.basic_ack(delivery_tag=method.delivery_tag)
            return
        
        # Validar datos requeridos
        required_fields = ['sale_id', 'product_id', 'quantity_sold']
        if not all(field in message for field in required_fields):
            logger.error(f"❌ Mensaje inválido, faltan campos: {message}")
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            return
        
        # Procesar lógica de negocio
        product_id = message['product_id']
        quantity = message['quantity_sold']
        
        if product_id in central_inventory:
            product = central_inventory[product_id]
            old_stock = product['stock']
            product['stock'] = max(0, product['stock'] - quantity)
            
            # Registrar como procesado
            processed_messages.add(message_id)
            
            logger.info(
                f"📊 Inventario actualizado - {product['name']}: "
                f"{old_stock} → {product['stock']} (mensaje: {message_id})"
            )
            
            # ACK explícito - solo después de procesamiento exitoso
            ch.basic_ack(delivery_tag=method.delivery_tag)
            
        else:
            logger.error(f"❌ Producto {product_id} no encontrado")
            # NACK sin requeue para evitar loop infinito
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            
    except json.JSONDecodeError as e:
        logger.error(f"❌ JSON inválido: {e}")
        ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
        
    except Exception as e:
        logger.error(f"❌ Error procesando mensaje: {e}")
        # Requeue para reintentar (RabbitMQ maneja límites)
        ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)

def start_consumer():
    """Consumer con configuración de producción"""
    params = pika.ConnectionParameters(
        host='localhost',
        credentials=pika.PlainCredentials('ecomarket_user', 'ecomarket_password'),
        heartbeat=600,
    )
    
    connection = pika.BlockingConnection(params)
    channel = connection.channel()
    
    # Configurar queue con misma configuración que producer
    channel.queue_declare(queue='sale_notifications', durable=True)
    
    # QoS: procesar solo 1 mensaje a la vez
    channel.basic_qos(prefetch_count=1)
    
    # Configurar consumer
    channel.basic_consume(
        queue='sale_notifications',
        on_message_callback=process_sale_message,
        auto_ack=False  # ACK manual para garantías
    )
    
    logger.info("🎧 Consumer iniciado, esperando mensajes...")
    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        logger.info("🛑 Deteniendo consumer...")
        channel.stop_consuming()
        connection.close()</pre>
            </div>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt para IA: Análisis de Implementación</h4>
            <pre>Revisa mi implementación de RabbitMQ y evalúa si cubre mis requerimientos:

Mi código: [pegar implementación arriba]

Contexto de producción:
- 400 ventas/día actual, creciendo a 2000/día
- Máximo 1% de mensajes perdidos tolerable
- Equipo pequeño, necesita ser mantenible
- Budget limitado para infraestructura

Evalúa específicamente:
1. ¿Esta implementación garantiza que no pierdo mensajes?
2. ¿Qué pasa si RabbitMQ se reinicia mientras hay mensajes en cola?
3. ¿Cómo maneja duplicados si hay reconexiones?
4. ¿Escalará para mi volumen proyectado?
5. ¿Qué problemas operacionales nuevos introduces?
6. ¿Hay configuraciones críticas que me faltan?

Para cada problema, dame:
- Por qué es importante
- Cómo se manifesta en producción  
- Código específico para solucionarlo</pre>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint de Fase 2</h3>
            <ul>
                <li>RabbitMQ corre con configuración de producción</li>
                <li>Publisher usa confirms y mensajes persistentes</li>
                <li>Consumer maneja idempotencia y ACK explícito</li>
                <li>Puedo explicar cada configuración en términos de garantías de negocio (e.g., ACK = no pérdidas, durable = sobrevive restart, prefetch=1 = no sobrecarga)</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="🧪">Fase 3: Validación y Pruebas de Resiliencia (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Demostrar que tu implementación realmente resuelve los problemas que identificaste en la Fase 0.</p>

        <div class="activity">
            <h3>🔥 Pruebas de Caos Controlado</h3>
            <p>Vamos a simular exactamente los escenarios que motivaron usar RabbitMQ:</p>

            <div class="scenario-box">
                <h4>⚡ Diagrama: Flujo de Validación - Probando las Garantías</h4>
                <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
PRUEBA 1: PERSISTENCIA DURANTE REINICIO
┌─────────┐    publish     ┌─────────────┐    restart    ┌─────────────┐
│Sucursal │ ────────────→  │ RabbitMQ    │ ──────────→   │ RabbitMQ    │
│5 ventas │                │ (guardando) │               │ (recupera)  │
└─────────┘                └─────────────┘               └─────────────┘
                                  │                             │
                                  ▼                             ▼
                           [5 mensajes                   [5 mensajes
                            en disco]                     intactos] ────→ Central
VALIDACIÓN: ¿Se procesan todos sin pérdida? ✅

PRUEBA 2: RESILIENCIA DEL CONSUMER  
┌─────────┐    publish     ┌─────────────┐    consume    ┌─────────┐
│Sucursal │ ────────────→  │ RabbitMQ    │ ────────────→ │Central  │
│1 venta  │                │             │               │ (Ctrl+C)│ ❌
└─────────┘                └─────────────┘               └─────────┘
                                  │                             │
                                  ▼                             ▼
                           [Mensaje queda                [Sin ACK = 
                            en queue]                     mensaje vuelve]
                                  │                             │
                                  ▼                             ▼
                           ┌─────────────┐                ┌─────────┐
                           │ RabbitMQ    │ ────────────→  │Central  │
                           │ (requeue)   │                │(restart)│ ✅
                           └─────────────┘                └─────────┘
VALIDACIÓN: ¿Se reprocesa automáticamente? ✅

PRUEBA 3: MANEJO DE VOLUMEN ALTO
┌─────────┐    20 ventas   ┌─────────────┐    procesa    ┌─────────┐
│Sucursal │ ═══════════→   │ RabbitMQ    │ ──1 por 1──→  │Central  │
│paralelas│   simultáneas  │ (prefetch=1)│    ordenado   │         │
└─────────┘                └─────────────┘               └─────────┘
     │                            │                            │
     ▼                            ▼                            ▼
[Todas completan           [Queue maneja            [Procesamiento
 en &lt;100ms]                 backpressure]            estable]
VALIDACIÓN: ¿Sin pérdidas ni sobrecarga? ✅

RESULTADO FINAL: SISTEMA ROBUSTO QUE CUMPLE PROMESAS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Persistencia garantizada    ✅ Recovery automático
✅ Procesamiento ordenado      ✅ Sin pérdida de datos  
✅ Escalabilidad validada      ✅ ROI demostrado
                </pre>
            </div>

            <h4>Prueba 1: Persistencia Durante Reinicio (10 min)</h4>
            <ol>
                <li>Envía 5 mensajes desde la sucursal</li>
                <li>Antes de que el consumer los procese, detén RabbitMQ: <code>docker stop rabbitmq</code></li>
                <li>Reinicia RabbitMQ: <code>docker start rabbitmq</code></li>
                <li>Inicia el consumer</li>
                <li><strong>Resultado esperado:</strong> Los 5 mensajes se procesan sin pérdida</li>
            </ol>

            <h4>Prueba 2: Resiliencia del Consumer (10 min)</h4>
            <ol>
                <li>Inicia el consumer</li>
                <li>Envía un mensaje</li>
                <li>Mata el proceso del consumer (Ctrl+C) ANTES de que termine de procesar</li>
                <li>Reinicia el consumer</li>
                <li><strong>Resultado esperado:</strong> El mensaje se reprocesa automáticamente</li>
            </ol>

            <h4>Prueba 3: Manejo de Volumen (10 min)</h4>
            <div class="code-block">
                <pre># Script de carga básico (para aprendizaje)
import asyncio
import httpx

async def load_test_simple():
    async with httpx.AsyncClient() as client:
        tasks = []
        for i in range(20):  # 20 ventas simultáneas
            task = client.post(
                "http://localhost:8001/sales",
                json={"product_id": 1, "quantity": 1}
            )
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        successes = len([r for r in results if not isinstance(r, Exception)])
        print(f"✅ Completadas: {successes}/20")

# Ejecutar: python -c "import asyncio; asyncio.run(load_test_simple())"</pre>
            </div>
            
            <div class="tip">
                <h4>🚀 Para Pruebas de Carga Realistas (Producción)</h4>
                <p>El script anterior es pedagógico. Para simular 100+ usuarios simultáneos:</p>
                <div class="code-block">
                    <pre># Instalar: pip install locust
# Archivo: locustfile.py
from locust import HttpUser, task, between

class EcoMarketUser(HttpUser):
    wait_time = between(1, 3)  # 1-3s entre requests
    
    @task
    def make_sale(self):
        self.client.post("/sales", json={
            "product_id": 1,
            "quantity": 1
        })

# Ejecutar: locust -f locustfile.py
# UI en http://localhost:8089 - configura 100 users, 10/s spawn rate</pre>
                </div>
                <p><strong>Beneficio:</strong> Visualización en tiempo real de throughput, latencias p95/p99, y error rate bajo carga.</p>
            </div>
            
            <p><strong>Resultado esperado:</strong> Todas las ventas se completan rápidamente, mensajes se procesan ordenadamente</p>
        </div>

        <div class="reflection">
            <h3>📊 Métricas de Validación</h3>
            <p>Compara el sistema anterior vs RabbitMQ:</p>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Métrica</th>
                        <th>HTTP Directo</th>
                        <th>Con RabbitMQ</th>
                        <th>Mejora</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Tiempo de venta</td>
                        <td>3-5 segundos</td>
                        <td>&lt;100ms</td>
                        <td>95% más rápido</td>
                    </tr>
                    <tr>
                        <td>Disponibilidad</td>
                        <td>98% (falla con central caído)</td>
                        <td>99.9% (venta siempre disponible)</td>
                        <td>10x mejor</td>
                    </tr>
                    <tr>
                        <td>Mensajes perdidos</td>
                        <td>2-3% en fallos de red</td>
                        <td>&lt;0.1% (solo en fallos graves)</td>
                        <td>20x más confiable</td>
                    </tr>
                    <tr>
                        <td>Complejidad operacional</td>
                        <td>Baja</td>
                        <td>Media (RabbitMQ + monitoring)</td>
                        <td>Costo aceptable</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>🎯 ROI Demostrado</h3>
            <p>Con los números de la Fase 0:</p>
            <ul>
                <li><strong>Antes:</strong> $1,440 perdidos por cada 8 minutos de caída</li>
                <li><strong>Después:</strong> $0 perdidos en ventas durante caídas (las ventas se procesan localmente)</li>
                <li><strong>Costo de implementación:</strong> ~40 horas de desarrollo</li>
                <li><strong>Payback:</strong> Se paga en la primera caída evitada</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint Final</h3>
            <ul>
                <li>Todas las pruebas de caos pasaron exitosamente</li>
                <li>Puedo demostrar ROI cuantificable vs sistema anterior</li>
                <li>Entiendo qué problemas nuevos introduce RabbitMQ y cómo monitearlos</li>
                <li>Tengo un plan para operación y escalamiento</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="🚀">Reflexión Final: El Verdadero Aprendizaje</h2>
        
        <div class="reflection">
            <h3>🤔 Preguntas Profundas para tu Equipo</h3>
            <ol>
                <li><strong>Evolución vs Revolución:</strong> ¿Por qué es importante evolucionar paso a paso en lugar de saltar directo a la solución "perfecta"?</li>
                <li><strong>Complejidad Justificada:</strong> ¿En qué momento exacto la complejidad adicional de RabbitMQ se vuelve valiosa vs el costo?</li>
                <li><strong>Patrones Universales:</strong> ¿Qué otros problemas en tu trabajo actual podrían beneficiarse de este mismo journey evolutivo?</li>
                <li><strong>Decisiones de Arquitectura:</strong> ¿Cómo cambiarían estas decisiones si fueras una startup de 5 personas vs una empresa de 500?</li>
            </ol>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt Final: Síntesis de Aprendizaje</h4>
            <pre>Ayúdame a sintetizar lo que aprendí sobre toma de decisiones arquitectónicas:

Mi journey:
1. Empecé con: [HTTP directo]
2. Identifiqué problemas: [fallos 2%, $X perdidos/mes]
3. Exploré alternativas: [retry, backoff, Redis, RabbitMQ]
4. Elegí: [RabbitMQ] por: [razones específicas]
5. Implementé con: [garantías de producción]
6. Validé que resuelve: [problemas originales]

Reflexiones para extraer:
1. ¿Qué principios generales puedo aplicar a otras decisiones técnicas?
2. ¿Cómo balanceo complejidad vs beneficio en el futuro?
3. ¿Qué preguntas debo hacerme antes de adoptar cualquier tecnología nueva?
4. ¿Cómo comunico este tipo de decisiones a stakeholders no técnicos?

Dame un framework mental que pueda reutilizar para cualquier decisión arquitectónica futura.</pre>
        </div>
        
        <div class="decision-matrix">
            <h4>📋 Framework Mental de Output (Ejemplo de respuesta del prompt anterior):</h4>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Principio</th>
                        <th>Pregunta Guía</th>
                        <th>Ejemplo de EcoMarket</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Cuantificar Dolor</strong></td>
                        <td>¿$X/mes perdido? ¿Escalará?</td>
                        <td>$1,440/día en fallos → $43,200/mes</td>
                    </tr>
                    <tr>
                        <td><strong>Evaluar Alternativas</strong></td>
                        <td>¿Escala 5x? ¿Dónde falla?</td>
                        <td>Retry OK now, RabbitMQ for growth</td>
                    </tr>
                    <tr>
                        <td><strong>Validar ROI</strong></td>
                        <td>¿Payback <3 meses?</td>
                        <td>Sí, primera caída evitada paga implementación</td>
                    </tr>
                    <tr>
                        <td><strong>Implementar Incremental</strong></td>
                        <td>¿Puedo probar con PoC?</td>
                        <td>Empecé con retry simple, evolucione paso a paso</td>
                    </tr>
                    <tr>
                        <td><strong>Medir Impacto Real</strong></td>
                        <td>¿Cumple promesas originales?</td>
                        <td>98% → 99.9% disponibilidad validada empíricamente</td>
                    </tr>
                </tbody>
            </table>
            <p><em>Este framework es transferible a: Database scaling, caching strategies, authentication systems, etc.</em></p>
        </div>

        <div class="tip">
            <h3>🎓 El Verdadero Valor</h3>
            <p>No has aprendido solo RabbitMQ. Has aprendido:</p>
            <ul>
                <li><strong>Metodología:</strong> Cómo evaluar y evolucionar soluciones incrementalmente</li>
                <li><strong>Justificación:</strong> Cómo cuantificar el valor vs costo de decisiones técnicas</li>
                <li><strong>Implementación:</strong> Cómo construir sistemas con características de producción</li>
                <li><strong>Validación:</strong> Cómo demostrar que una solución realmente resuelve el problema</li>
            </ul>
            <p><strong>Esto es transferible a cualquier decisión arquitectónica futura.</strong></p>
        </div>
    </div>

    <p style="text-align: center; margin-top: 30px;">
        🎉 ¡Felicitaciones! Ahora sabes no solo CÓMO implementar colas de mensajes, sino CUÁNDO y POR QUÉ hacerlo.
    </p>
</body>
</html>